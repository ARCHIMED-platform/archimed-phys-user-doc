[
{
	"uri": "/",
	"title": "ARCHIMED user documentation",
	"tags": [],
	"description": "",
	"content": "  ARCHIMED user documentation Welcome to the user documentation for ARCHIMED.\nYou can navigate through the documentation using your keyboard arrows. Use  and  while reading a page, and  and  to navigate between pages.\n "
},
{
	"uri": "/1-introduction/",
	"title": "Welcome",
	"tags": [],
	"description": "",
	"content": "  ARCHIMED user documentation The ARCHIMED simulation platform uses 3D virtual stands as a support for numerical simulations of biophysical processes such as leaf irradiation, transpiration and temperature and ultimately carbon assimilation. By doing so, detailed information can be integrated from the individual leaf scale up to the individual plant scale, even within complex stands such as agroforestry systems. Simple numerical methods are used for solving multiple feedbacks between light, energy, water and CO2 transfers at leaf, plant and plot scales. Numerical calculations applied at different scales allow simple implementation of complex models involving intricate processes.\nThe documentation is paired with example files that you can download to follow through. It is best to follow the documentation with these files opened for best understanding.\n  "
},
{
	"uri": "/2-getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": "  Chapter 0 This chapter is all about making you first simulation. We believe running the model once before starting digging into the details is way more fun !\n "
},
{
	"uri": "/2-getting-started/1-example-data/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "  Data To run an ARCHIMED simulation, you‚Äôll need a working example. Please download it from here:\n  Attachments   example_inputs.zip  (440 ko)    At the moment, don‚Äôt worry about the organization of the folder nor the file contents. We‚Äôll get into this very soon in the organization page.\n ARCHIMED executable ARCHIMED is programmed in Java. The main benefit is that a same .jar file can be executed in all platforms compatible with Java (i.e. Windows, Mac, Linux‚Ä¶). Please download the executable (e.g.¬†archimed.jar) and place it at the root of the example directory (meaning next to the config.yml file).\n "
},
{
	"uri": "/2-getting-started/2-download_archimed/",
	"title": "Run ARCHIMED",
	"tags": [],
	"description": "",
	"content": "  Run a simulation Then, open a terminal and run the following command:\njava -jar archimed.jar config.yml And that‚Äôs it ! You ran an ARCHIMED simulation ! Note that it can take a minute to finish.\nCommand details The java -jar archimed.jar part of the command just tells Java to execute the archimed.jar file. If your ARCHIMED .jar file is named differently, please name it properly, e.g.:\njava -jar archimed_custom_name.jar config.yml The last argument (config.yml) is used by ARCHIMED itself. It is the path to the configuration file for the simulation. If you‚Äôre executing ARCHIMED from a folder and the simulation files are in another, you can use this argument as a relative or absolute path, e.g.:\njava -jar archimed.jar C:/users/yourusername/test/config.yml The argument can also be quoted, e.g.¬†\"./test/config.yml\"\n Open a terminal  For windows users: right click inside the folder while holding the shift key, and click on ‚Äúopen Powershell‚Äù. It will open a Powershell prompt in the right folder. Then you can execute the command given above;\n For Mac users, press command + spacebar from the folder;\n For Linux users, well, you know already.    "
},
{
	"uri": "/2-getting-started/3-visualize_output/",
	"title": "Visualization",
	"tags": [],
	"description": "",
	"content": "  Render the output After executing ARCHIMED in the example folder, the simulation outputs are found at this path: ./output/simdir. There are several files here, and one is especially useful for visualizing the results in 3D: coffee.opf.\nTo render the results, please download XPlo from the AMAPStudio website. Then open XPlo, press ctrl+I, choose opf, and navigate to the location of coffee.opf and open it.\nXplo will open and 3D render the example coffee. Now you can color the coffee components by any output variable by clicking on: Geometry -\u0026gt; Colorizer.\n "
},
{
	"uri": "/2-getting-started/4-commandline_arguments/",
	"title": "Command line arguments",
	"tags": [],
	"description": "",
	"content": "  Command details We saw earlier that a simulation is started using the following command line:\njava -jar archimed.jar config.yml The java -jar archimed.jar part of the command just tells Java to execute the archimed.jar file, and the second one (config.yml) is an argument used to give the path to the configuration file to ARCHIMED.\nBut more options are also available from ARCHIMED.\nTo get all the options from ARCHIMED, you can consult the help by running it without any argument:\njava -jar archimed.jar It will return something as follow (depending on the version):\n[INFO ] 2020-06-16 16:59:53.747 [main] ArchimedMain - build time 2020-06-16T13:30:26+0200 [INFO ] 2020-06-16 16:59:53.749 [main] ArchimedMain - commit b7a83300256fc3cfc98b1f7088ae613600a61398 on branch wavebands [INFO ] 2020-06-16 16:59:53.749 [main] CommandLineOptions - parsing options usage: archimed \u0026lt;property file\u0026gt; [-d] [--exclude-objectid-output \u0026lt;arg\u0026gt;] [-h] [--meteo-substep-v1] [--meteo-sunpos-v1] [--no-area-ratio] [--no-meteo-overlap-check] [--no-reduced-pixtable] [--no-upperhit-pixtable] [-p] [--prop \u0026lt;arg\u0026gt;] [--scattering-end-method \u0026lt;arg\u0026gt;] Light interception and photosynthesis on 3D plant models -d,--debug debug mode --exclude-objectid-output \u0026lt;arg\u0026gt;exclude given object id from file outputs -h,--help print detailed help --meteo-substep-v1 meteo step subdivision method V1 --meteo-sunpos-v1 meteo step sun positioning method V1 --no-area-ratio disable area ratio correction --no-meteo-overlap-check disable meteo time steps overlapping checking --no-reduced-pixtable do not use \u0026#39;reduced\u0026#39; pixel table --no-upperhit-pixtable do not use \u0026#39;upper hit\u0026#39; pixel table -p,--parallel enable parallel computations --prop \u0026lt;arg\u0026gt; define/override configuration property, eg. --prop file=xxx --scattering-end-method \u0026lt;arg\u0026gt; scattering iteration ending method (0,1,2)``` You can run ARCHIMED with any of these options enabled, but at the moment it is best not digging into much details about this. We will see those details later in the documentation for power users.\n "
},
{
	"uri": "/3-inputs/",
	"title": "Inputs",
	"tags": [],
	"description": "",
	"content": "  Chapter 1  Model inputs A few files are required as ARCHIMED input: the general configuration, the meteorology data, the models configuration, and the scene. This chapter details the specifics of these files.\nAn example folder for inputs can be downloaded here:\n  Attachments   example_inputs.zip  (440 ko)     "
},
{
	"uri": "/3-inputs/1-organisation/",
	"title": "Organisation",
	"tags": [],
	"description": "",
	"content": "  Inputs organisation Several input files are mandatory for an ARCHIMED simulation: the general configuration file (config.yml), the meteorology data (meteo.csv), the models configuration (e.g. plant_coffee.yml), and the scene (e.g.¬†.ops and .opf files). There is also an input file for the physical constants (const.yml) that is optional because ARCHIMED defines default values if not provided.\nIt is recommended to follow along with the example files provided in the previous page opened in your preferred editor. We recommend Atom or VS Code. They are both open source and have packages to view and edit YAML (.yml), CSV (.csv) and XML files (.ops, .opf and .gwa).\nHere is a tree view of the files and folders with a little description for each:\nüì¶ ‚îú‚îÄ‚îÄ üìúconfig.yml # -\u0026gt; Here is the general configuration file ‚îú‚îÄ‚îÄ üìúconst.yml # -\u0026gt; constants used in the model ‚îú‚îÄ‚îÄ üìúmeteo.csv # -\u0026gt; the meteorology file ‚îú‚îÄ‚îÄ üìÇmodel # -\u0026gt; all the models configuration files are listed in this folder ‚îÇ¬†‚îî‚îÄ‚îÄ üìúplant_coffee.yml # An example config for a Coffea plant ARCHIMED. ‚îú‚îÄ‚îÄ üìÇscene # -\u0026gt; all the 3D scenes files are listed in this folder ‚îÇ¬†‚îú‚îÄ‚îÄ üìúcoffee.ops # An example scene with one coffee ‚îÇ¬†‚îî‚îÄ‚îÄ üìÇopf # The folder that list the available `.opf` files for the plant geometry ‚îÇ¬†‚îî‚îÄ‚îÄ üìúcoffee.opf # An example coffee plant geometry ad topology file) ‚îî‚îÄ‚îÄ üìúsoil.yml # An example soil file Many input files use the YAML format. It is a data serialization language designed to be directly writable and readable by humans. There are tons of resources on the web (e.g. learnxinyminutes.com, Wikipedia, this blog post), but you should be fine just by seeing the files structure.\nThe names of the input files are not mandatory, but it is best to keep a rather standard naming nevertheless. For example soil.yml can become soil_1.yml or soil_montpellier.yml, but it is still recommended to keep ‚Äúsoil‚Äù in the name.\n  "
},
{
	"uri": "/3-inputs/2-general_config/",
	"title": "General configuration file",
	"tags": [],
	"description": "",
	"content": "  config.yaml This file lists the main configuration parameters for a simulation. It controls the simulation by pointing towards the files for the meteorology data (e.g. meteo.csv), the models configuration (e.g. plant_coffee.yml), and the scene (e.g. cafeier.ops).\nAlthough entries in the configuration file are not ordered, the following example is organized in sections for clarity.\nA full working example is available in the folder presented in the previous page (‚Äúconfig.yml‚Äù). It is highly recommended to open this file to follow along.\nInput files At the beginning of the example file, we find the three parameters used to enter the path to the other files:\nscene: scene/cafeier.ops # Path to a scene, i.e. ops, opf or gwa file. models: - models/plant_coffee.yml # Path to the models for the coffee - soil.yml # Path to the models for the soil file meteo: meteo.csv # Path to the meteo file The scene file is typically an .ops file that is used to build a 3D scene with plants and other geometries. It lists each instance of an object in the scene (e.g. a coffee plant), the Group it belongs to and its position (see the sections about .ops and .opf/.gwa files for more details).\nThe model files store the parameters associated to a Group named in the .ops file. Each Group present in the .ops file must have a model file listed in the models parameter. The example .ops file lists the files to the models for the coffee group and the soil group. The models associated to the coffee are found in the models/plant_coffee.yml file, and the models associated to the soil module are found in the soil.yml file. This file is empty at the moment but prefigures future model implementations related to the soil (e.g water transfer).\nIf there are several groups (e.g. a coffee tree and an oil palm) in the scene (.ops), the models files should all be listed as follows:\nmodels: - models/plant_coffee.yml # Path to the models for the coffee - models/plant_elaeis.yml # Path to the models for the palm plant - soil.yml # Path to the models for the soil file The meteo parameter points to a meteo file. See this section for more details.\n Simulation controls The next parameter allows to filter the meteorology steps from the configuration file if needed:\nmeteo_range: 2, 3 # use only steps from 2 to 3 (inclusive, start from 1) in meteo file #meteo_range: 2016/07/01 8:00:00, 2016/07/01 12:00:00 # use only steps between given date/time It is given as a range in terms of either: - steps index (starting from 1), e.g.: 2,5 for steps 2, 3, 4 and 5 - dates, e.g.¬†2016/07/01 8:00:00, 2016/07/01 12:00:00.\nThen we find some parameters for the simulation:\nscene_rotation: 0 # Rotation of the scene from the North axis (degrees) sky_sectors: 16 # Must be either 1, 6, 16, 46, 136 or 406 all_in_turtle: false # false: direct radiation is computed using the true sun position; true: direct radiation is computed using sky sectors radiation_timestep: 5 # [minutes] frequency for the computation of the sun\u0026#39;s radiation within each timestep scattering: true # true: compute multiple scattering pixel_size: 3 # Size of the side of the pixel, relates to the number of rays sent in the scene for each direction (cm pixels-1). Decrease value for increased resolution. toricity: true # Make the scene toric (if false, increase the plot boundaries so all components are sampled) cache_pixel_table: false # true: pixel tables are cached on disc instead of kept in memory (slower but use less memory + allow to reuse them). cache_radiation : true # true : precomputed intercepted/scattered radiation to speed up simulation scene_rotation is used to rotate the scene from the North axis, and is provided in degrees.\nsky_sectors is used to define how many sectors are used to divide the semi-hemisphere of the sky (called the turtle). ARCHIMED uses discrete directions for the computation of light interception (at least for the diffuse light). These directions are given by each sector of the turtle, so the more directions there are, the most precise is the computation of light interception, but also the more computation there are, so the more time it will take to complete a simulation. A good rule of thumb is to take at least 16 directions if the interception is needed at plant scale, 46 if it is for branch-scale, and 136 or even 406 for leaf scale.\n This recommendation is quite robust because the error tends to be compensated from one scale to the other. For example if we simulate a palm tree with 16 directions, the error would be quite high if we compare with observations at leaflet scale. But if we integrate at leaf scale, it would be quite close to the observations, and even closer if we integrate over the whole plant.\n Sky sectors defined for a turtle splitting of 46 sectors\n all_in_turtle is a Boolean that defines if the direct radiation is computed using the true sun position (true), or if the direct radiation is computed using sky sectors (false). In the second case, the sun direction is still computed precisely, but the radiation is divided between sky sectors close to the sun position, using the same computation as for the diffuse light. The latter method is faster than the former. In general it is more precise to use all_in_turtle: true, but the difference tends to disappear when there is a sufficient number of sectors (e.g. 46 sectors).\nradiation_timestep. The duration of each time-step for the simulation is given in the meteorology file. Because the sun moves rapidly in the sky, especially in the morning, the direct radiation received on a plane at the surface of the earth changes rapidly too. Think of the radiation you receive at 8h in the morning and then at 9h00. They differ quite a bit. Hence, the computation of the light interception could be biased if we were to use only the average position of the sun for a time-step due to the non-uniformity of the radiation inside this time-step (i.e. the average radiation in the time-step is different than the radiation at the average sun position).\nTo alleviate this issue, it is possible to discretize the time-step in sub-steps of radiation_timestep minutes. The sun position and the radiation are both computed for each sub-step, and the resulting position and radiation used for the time-step come from the position at the barycenter of all positions, and the integrated radiation of all the sub-steps inside the time-step. It is an efficient way to approximate the effective radiation in a time-step when the time-step duration implies a substantial movement of the sun.\nIt is generally admitted that a radiation_timestep of 5 is largely sufficient.\nscattering is a Boolean to choose if light scattering is computed or not. This computation is probably the most ressource demanding in ARCHIMED, but is quite important for a precise estimation of the light interception of an object, especially when computing photosynthesis.\npixel_size defines the size of the side of a pixel (cm pixels-1). The light interception is computed using ‚Äúpixel tables‚Äù in ARCHIMED. There is a pixel table for each sky sector of the turtle, and it is projected onto the ground of the scene. Light rays are sent from the sky sector to each pixel from the pixel table, and the ‚Äúhits‚Äù with the objects from the scene are computed using these rays. Because the pixel_size defines the size of the pixels in the scene, it can be viewed as a way to change the ‚Äúresolution‚Äù of the computation. If we decrease its value, we get more pixels with a smaller size, so we cast more rays through the scene.\nToricity toricity is a Boolean controlling the plot toricity. The use of the toricity option allows generating virtually infinite canopies from the plot defined in the .ops. The name toricity comes from the shape and properties of a Torus, where the conditions of one end are close to the ones from the other end.\nA flat scene can be turned into a torus to connect the scene boundaries between each others. Attribution: Lucas Vieira / Public domain, from https://commons.wikimedia.org/wiki/File:Torus_from_rectangle.gif\n In ARCHIMED, the light rays reaching an horizontal boundary of the scene (e.g maximum Y boundary) re-enter the scene from the opposite direction of the scene (e.g minimum Y boundary).\nHere is our example 3D scene with a coffee tree planted near the boundary of the scene:\n A coffee tree by rvezy on Sketchfab  A simulation of the light interception in this scene with the toricity set to true would give the following image after rendering in Xplo with the soil colored by the value of the light it absorbs to get a feeling of the projected shade from the coffee tree:\nThe scene toricity can be seen looking at the projected shade by the coffee onto the ground. The shade of the coffee is projected on almost all corners of the scene because the scene is virtually repeated infinitely, so there is virtually a coffee tree near each corner of the scene. If we copy/paste the results from the previous scene 4 times in a new .ops, we get a better idea of the effect of toricity after rendering in XPlo:\nA coffee tree in a toric 3x3m scene, repeated 4 times after simulation. The soil is colored by Ra_PAR_f, the in \\(W m_{component}^{-2}\\).\n cache_pixel_table is a Boolean used to define if the pixel tables are cached on disc instead of keeping them in-memory. Caching the pixel tables (true) result in a slower simulation due to writing, but uses less RAM. Users with low-end computers can activate this option if they have not enough memory for a simulation.\nThe cache_radiation parameter allows to cache in-memory the computation of light interception (interception and scattering) for each node in all directions of the turtle. This allows to compute only once the light received by a node from each direction in terms of relative radiation, and then to only compute the absolute value using the global radiation of the step for the following steps. It is generally admitted this parameter should be set to true when the number of time-steps to simulate is greater than the number of directions, i.e.¬†nrows(meteo) \u0026gt; sky_sectors. It should be set to false otherwise because the extra computations needed for the cache is generally greater than the independent simulation of each step (computation overhead).\nFor example a simulation taking ~3.4 minutes (23M rays, 46 directions) for each time-step can be decreased to ~2 seconds with the option activated.\n Careful, activating this parameter results in higher memory consumption.\nThis option can be used to cache the radiation interception computation on disk for further simulations at another time, but it should be used on the exact same scene (same geometry).\n   Outputs Then, the following parameters control the outputs from the model. In ARCHIMED, the outputs of the model are placed in a folder associated to a given simulation, which are all grouped in a more general output directory.\n# OUTPUTS output_directory: output # Path to the output directory (the folder is created if not already existing) simulation_directory: simdir # Optional : path to the simulation directory (replace the automatic counter based directory name generation) The output_directory parameter design the name of the general output directory where the simulation folders will be grouped.\nThe simulation folders are named automatically following an incremental numbering, e.g.¬†the first simulation is named 000001, the second 000002, etc‚Ä¶ If the user wants to name the simulation folder differently, he can use the simulation_directory to provide it. To use again the automatic numbering, please remove the parameter altogether.\n It is good practice to use a separate output_directory for different unrelated projects, and to name the simulation using simulation_directory after the use case, such as a particular planting design or a different age.\nFor example if we have two projects, one to simulate different planting designs of coffee trees in Costa Rica, and one to simulate eucalyptus trees in Brazil, we would use output_directory: output_coffee_designs, and then output_directory: output_euca_brazil respectively. And the simulation names would be adapted to the use case to get a folder structure such as:\n üì¶ ‚îú‚îÄ‚îÄ üìúconfig.yml ‚îú‚îÄ‚îÄ üìúconst.yml ‚îú‚îÄ‚îÄ üìúmeteo.csv ‚îú‚îÄ‚îÄ üìÇmodels ‚îÇ¬†‚îî‚îÄ‚îÄ ... ‚îú‚îÄ‚îÄ üìÇscene ‚îÇ¬†‚îî‚îÄ‚îÄ ... ‚îú‚îÄ‚îÄ üìÇoutput_coffee_designs ‚îÇ¬†‚îú‚îÄ‚îÄ üìÇdesign_1 ‚îÇ¬†‚îÇ ‚îî‚îÄ‚îÄ ... ‚îÇ¬†‚îú‚îÄ‚îÄ üìÇdesign_2 ‚îÇ¬†‚îÇ ‚îî‚îÄ‚îÄ ... ‚îÇ¬†‚îî‚îÄ‚îÄ üìÇ... ‚îú‚îÄ‚îÄ üìÇoutput_euca_brazil ‚îÇ¬†‚îú‚îÄ‚îÄ üìÇage_1 ‚îÇ¬†‚îÇ ‚îî‚îÄ‚îÄ ... ‚îÇ¬†‚îú‚îÄ‚îÄ üìÇage_2 ‚îÇ¬†‚îÇ ‚îî‚îÄ‚îÄ ... ‚îÇ¬†‚îî‚îÄ‚îÄ üìÇ... ‚îî‚îÄ‚îÄ üìúsoil.yml Several files are written in each simulation_directory, but the user can control if some are needed or not.\nwrite_summary: true # If true export the simulation summary in a csv file The write_summary parameter is a Boolean to choose if a summary file is needed for the simulation. This file is a .csv file summarizing the area and intercepted radiation (Ri_q) grouped by time step, group, type, and item_id.\nMore files are available for simulation outputs:\n the component_values.csv file that provide the values of the variables needed at component scale (e.g. the interception of each leaf) for each individual object (i.e. a plant, or a .gwa);\n the scene files (.opf, .gwa and .ops files), which are a copy of the original scene, but with the topology and geometry files of each objects enriched with new simulated variables.\n  The component_values.csv is written only if the component_variables parameter is present in the config.yml file (see below). The scene files are only present if the export_ops parameter is set to true:\nexport_ops: true Component variables Many variables are available as outputs from ARCHIMED to write into the component_values.csv file. The component_variables parameter lists the variables needed as outputs:\n# List of columns in the component_values.csv file: component_variables: step_number: true # Index of the step step_duration: true # Step duration in seconds item_id: true # Item id (as given as plant_id in the OPS) component_id: true # Component unique ID in the item (as read in the OPF) group: true # Functional group (as given by the Group field in the plant.yml file) type: true # Component type (as given by the Type names in the plant.yml files) area: true # Component area (i.e. mesh area, m2) surface_hits: true # Component hit count per area unit (m-2) barycentre_x: false # Barycentre of the component x (~ X position of the component). barycentre_y: false # Carefull, barycentre_* variables are computed, so it slows down model execution time a little bit barycentre_z: false # Carefull, this output increase memory use (it is deleted during model execution) sky_fraction: false # Intercepted light: Ri_PAR_0_f: false # Order 0 (without scattering) irradiance (intercepted light) for PAR (W m[component]-2) Ri_PAR_0_q: false # Order 0 irradiance for PAR (J component-1 timestep-1) Ri_NIR_0_f: false # Order 0 (without scattering) irradiance (intercepted light) for NIR (W m[component]-2) Ri_NIR_0_q: false # Order 0 irradiance for NIR (J component-1 timestep-1) Ri_PAR_f: false # Order n (with scattering) irradiance for PAR (W m[component]-2) Ri_NIR_f: false # Order n (with scattering) irradiance for PAR (W m[component]-2) Ri_TIR_f: false # Intercepted TIR (from atmosphere + environment, W m[component]-2). Ri_PAR_q: false # Order n irradiance for PAR (J component-1 timestep-1) Ri_NIR_q: false # Order n irradiance for NIR (J component-1 timestep-1) Ri_TIR_q: false # Intercepted TIR (from atmosphere + environment, J component-1 timestep-1). # Absorbed light Ra_PAR_0_f: false # Order 0 absorbed PAR (W m[component]-2) Ra_NIR_0_f: false # Order 0 absorbed NIR (W m[component]-2) Ra_PAR_0_q: false # Order 0 absorbed PAR (J component-1 timestep-1) Ra_NIR_0_q: false # Order 0 absorbed NIR (J component-1 timestep-1) Ra_PAR_f: false # Order n absorbed PAR (W m[component]-2) Ra_NIR_f: false # Order n absorbed NIR (W m[component]-2) Ra_TIR_f: false # Absorbed TIR (Intercepted - emmitted, W m[component]-2) Ra_PAR_q: false # Order n absorbed PAR (J component-1 timestep-1) Ra_NIR_q: false # Order n absorbed NIR (J component-1 timestep-1) Ra_TIR_q: false # Absorbed TIR (Intercepted - emitted, J component-1 timestep-1) # Assimilation An_f: false # Net CO2 assimilation rate (¬µmol m[component]-2 s-1) An_q: false # Net assimilated CO2 (¬µmol component-1 timestep-1) Gs: false # Stomatal conductance for CO2 (mol m-2 s-1) # Energy H_q: true # Sensible heat flux (W m[component]-2) H_f: true # Sensible heat quantity (J component-1 timestep-1) LE_q: true # Latent heat flux (W m[component]-2) LE_f: true # Latent heat quantity (J component-1 timestep-1) Tr_f: false # Transpiration flux (mm m[component]-2 s-1) Tr_q: false # Transpiration quantity (mm component-1 timestep-1) T: true # Temperature (Celsius degree) In the example file all variables available as outputs from the model are listed, but the list can be reduced to only provide the variables needed, such as:\n# List of columns in the component_values.csv file: component_variables: step_number: true # Index of the step step_duration: true # Step duration in seconds Ra_PAR_f: true # Order n absorbed PAR (W m[component]-2) This would only return the variables listed, and all others will be set as false as default.\n Component variables The opf_variables parameter works exactly as the component_variables, but they control the variables added to the .opf (and .gwa) files instead.\nOne example using the short format would be :\nopf_variables: Ra_PAR_f: true # Order n absorbed PAR (W m[component]-2)  Here the .opf files of all plants and .gwa files of all objects in the scene will be copied into the simulation folder and enriched with the simulated Ra_PAR_f for each component.\n Using YAML anchors Most of the time the required opf_variables will be the same than the component_variables. You can use anchors to tell ARCHIMED to re-use the same values in opf_variables than in component_variables:\ncomponent_variables: \u0026amp;outvars # defining an anchor here with \u0026amp;id step_number: true step_duration: true Ra_PAR_f: true opf_variables: *outvars # The content of the parameter where \u0026quot;\u0026amp;outvars\u0026quot; was defined will be copied for opf_variables Finally, there is a last parameter:\nopf_overwrite_variables: true # NB: if you need the same as component_variables, use YAML anchors as in this example. This parameter is a Boolean for choosing if a variable that would already exist in the OPF should be overwritten or not. Keep in mind that the original .opf files are not modified, only the copy made in the simulation folder changes.\n Summary table of the parameters     Name Description Value domain Unit Mandatory Default value    scene Path to scene file loaded by the application (e.g.¬†OPS). Path  Y   models List of path(s) to models file(s) List of paths  Y   meteo Path to meteo file path  Y false  scene_rotation Rotation of the scene from the North axis real degree N 0  sky_sectors Number of sky sectors Integer: 1, 6, 16, 46, 136 or 406  Y   all_in_turtle If false, the direct radiation is accounted for separately; else the direct radiation is assigned to sky sectors boolean  N true  radiation_timestep Determines the frequency of computation of the sun‚Äôs positions within a period real minute Y   scattering Compute multiple scattering? boolean  N true  pixel_size Size of a pixel side (gives the resolution) real cm pixel-1 Y   toricity Determines if plot is virtually infinitely repeated in all directions. TORIC_INFINITE_BOX_TOPOLOGY  N TORIC_INFINITE_BOX_TOPOLOGY  cache_pixel_table Cache pixel tables on disc ? (slower but use less memory + allow to reuse them). boolean  N false  cache_radiation Pre-compute relative interception and scattering (faster when nsteps \u0026gt; sky_sectors) boolean  N false  output_directory Path to the general output directory Path to folder (create it if missing)  Y   simulation_directory Name of the simulation directory in output_directory. Overrides existing directory if it exists. If missing, use incremental numbering for naming. Folder name  N Incremental counter for the name  component_variables List of the output variables written in component_values.csv. List of variable and state (true or false)  N None  opf_variables List of the attributes written in the OPF file(s). List of variable and state (true or false)  N None  write_summary If true, write simulation summary to summary.csv. boolean  N false       "
},
{
	"uri": "/3-inputs/3-constants/",
	"title": "Constant parameter file",
	"tags": [],
	"description": "",
	"content": "  const.yml This file lists all constants and their values used in ARCHIMED. The file is optional. The example file provided below lists the default values used in ARCHIMED (their values are also provided in this page for information).\n  Attachments   const.yml  (1 ko)    You can safely ignore this page for the vast majority of use cases. You don‚Äôt need to know or understand everything in this page, it is only provided for convenience in case the user has specific needs.\n  co2_to_heat_boundary_layer_conductance is used to convert the boundary layer conductance to heat into the boundary layer conductance to \\(CO_2\\) with the following equation (default value is 1.32):  \\[Gb_{CO_2}=\\frac{Gb_{heat}}{co2\\_to\\_heat\\_boundary\\_layer\\_conductance}\\]\n heat_to_water_boundary_layer_conductance is used to convert boundary layer conductance to heat into boundary layer conductance to water (default to 1.075):  \\[Gb_{H_2O}= Gb_{heat} \\cdot heat\\_to\\_water\\_boundary\\_layer\\_conductance\\]\n co2_to_water_conductance is used to convert a stomatal conductance to \\(CO_2\\) into a stomatal conductance for \\(H_2O\\) (default to 1.57):  \\[Gb_{H_2O}= Gb_{CO_2} \\cdot co2\\_to\\_water\\_conductance\\]\n forced_heat_BL_conductance_proportionality_factor is used compute the boundary layer conductance for heat under forced convection (default to 1000/3):  \\[Gbh_{forced} = \\frac{\\sqrt{\\frac{wind}{specificLength}}}{C}\\]\nSee Leuning et al. (1995) for more details (equation E1 from Appendix E).\n atmospheric_CO2_concentration defines the default \\(CO_2\\) concentration in the atmosphere in ppm. It is used only if the \\(CO_2\\) variable is missing from the meteorology file (default to 400 ppm).\n atmospheric_O2_concentration defines the \\(O_2\\) concentration in the atmosphere in ppm. Default to 210.0 ppm. It is used to compute the rubisco-limited carboxylation rate \\(W_c\\) (\\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)):\n  \\[W_c = \\frac{(Vc_{max} \\cdot C_i)}{C_i + K_c \\cdot (1.0 + \\frac{atmospheric\\_O2\\_concentration}{K_o})}\\] See Farquhar, von Caemmerer, and Berry (1980) for more details (equation 9).\n water_vapour_to_dry_air_molecular_weight_ratio is used to convert molecular weight of water vapour into dry air. Default to 0.622. It is used to compute the psychrometric constant (\\(\\gamma\\), in \\(kPa \\cdot ¬∞C^{-1}\\)) from atmospheric pressure (kPa):  \\[\\gamma = \\frac{Cp_{air} \\cdot P}{water\\_vapour\\_to\\_dry\\_air\\_molecular\\_weight\\_ratio \\cdot lambda}\\]\n air_specific_heat_constant_pressure is the specific heat of air at constant pressure in \\(J \\cdot K^{-1} \\cdot kg^{-1}\\). Default to 1013. It is used to compute the psychrometric constant (see equation above).\n gravitational_acceleration is the gravitational acceleration in \\(m \\cdot s^{-2}\\) and is used to compute the pressure from the elevation. See Stull (2012) and the BigLeaf R package for more details.\n celsius_to_kelvin is used to convert Celsius degrees into Kelvin degrees. Default to 273.15.\n universal_gas_constant defines the universal gas constant in \\(J \\cdot mol^{-1} \\cdot K^{-1}\\). Default to 8.314. It is used to compute the temperature dependence for the assimilation parameters and to convert conductance in \\(mol \\cdot m^{-2} \\cdot s^{-1}\\) into \\(m \\cdot s^{-1}\\).\n dry_air_gaz_constant is the gaz constant of dry air (Rd) in \\(J \\cdot kg^{-1} \\cdot K^{-1}\\). Default to 287.0586. It is used to compute the air density following Foken and Napo (2008):\n  \\[R_{specific} = \\frac{P}{Rd \\cdot T_{air}}\\]\nSee here for more details (Specific gas constant section).\n ref_atmospheric_pressure_sea_level is the reference atmospheric pressure at sea level. It defaults to 101.325 kPa.\n Stefan_Boltzmann_sigma is the Stefan-Boltzmann constant (noted \\(\\sigma\\)). Its default value is at 5.67477e-08 \\(W \\cdot m^{-2} \\cdot K^{-4}\\). It is used to compute the emission of thermal infrared radiation (Re_TIR) by a black body:\n  \\[Re_{TIR} = \\sigma \\cdot T^4\\] - sun_irradiance_to_photons is used to convert sunlight irradiance \\(W \\cdot m^{-2}\\) into PPFD (\\(\\mu mol \\cdot m^{-2} \\cdot s^{-1}\\)). It defaults to 4.57 \\(\\frac{\\mu mol \\cdot m^{-2} \\cdot s^{-1}}{W \\cdot m^{-2}}\\)\nReferences Farquhar, G. D., S. von von Caemmerer, and J. A. Berry. 1980. ‚ÄúA Biochemical Model of Photosynthetic CO2 Assimilation in Leaves of C3 Species.‚Äù Planta 149 (1): 78‚Äì90.\n Foken, Thomas, and Carmen J Napo. 2008. Micrometeorology. Vol. 2. Springer. https://doi.org/10.1007/978-3-540-74666-9.\n Leuning, R., F. M. Kelliher, DGG de Pury, and E.-D. SCHULZE. 1995. ‚ÄúLeaf Nitrogen, Photosynthesis, Conductance and Transpiration: Scaling from Leaves to Canopies.‚Äù Plant, Cell \u0026amp; Environment 18 (10): 1183‚Äì1200.\n Stull, Roland B. 2012. An Introduction to Boundary Layer Meteorology. Vol. 13. Springer Science \u0026amp; Business Media. https://doi.org/10.1007/978-94-009-3027-8.\n    "
},
{
	"uri": "/3-inputs/4-scene/",
	"title": "3D scene",
	"tags": [],
	"description": "",
	"content": "  3D scene The 3D scene is defined using several files. First, individual objects are defined using:\n .opf files for plants. These files describe the geometry and topology of the plant; .gwa objects for any other object, than defines its geometry.  Then, a scene file (.ops) is used to place these individual objects in a 3D scene. This chapter presents the details about the scene files.\n "
},
{
	"uri": "/3-inputs/4-scene/1-ops/",
	"title": "Scene file",
	"tags": [],
	"description": "",
	"content": "  .ops The .ops file defines a 3D scene compatible with ARCHIMED and AMAPStudio. The file is used to define a scene, and place 3D objects inside. The .ops file used in ARCHIMED is a subset of the .ops file from AMAPStudio, meaning they don‚Äôt implement all the features (e.g.¬†chaining).\nExample Here is the content of an example file for a scene with two coffee trees:\n# T xOrigin yOrigin zOrigin xSize ySize flat T 0 0 0 2 2 flat #[Archimed] coffee #sceneId objectId FilePath x y z scale inclinationAzimut inclinationAngle rotation 1 1 opf/P6_Ru_ii_L2P02.opf 0 0 0 0 0 0 0 1 2 opf/P6_Ru_ii_L2P02.opf 1 1 0 0 0 0 0 You can download the example file here:\n  Attachments   coffee.ops  (0 ko)     Description Here is a step-by-step description of the content of the .ops file.\nComments can be added by starting a line with a hash sign: #.\n The first line defines the terrain properties, with its boundaries in X and Y, the lower value for Z, and the slope:\nT 0 0 0 2 2 flat The example .ops file attached has a comment line before this line to remember the order of the values.\n The values in the terrain line defines respectively:\n- T is used as an identifier for the terrain properties line. It is mandatory.\n- The coordinates of the origin for X, Y and Z values. These values are typically set to 0.\n- The coordinates of the boundaries in X and Y.\n- The slope of the terrain. At the moment, only a flat scene is allowed in ARCHIMED. This is due to the toricity property of the scene, but future development will allow sloped terrains for non-toric scenes.\nThe terrain line is optional in AMAPStudio, but mandatory for ARCHIMED.\n Then comes a special comment read by ARCHIMED but not AMAPStudio. It starts with a # so it is not read by AMAPStudio, and a special sign [Archimed]:\n#[Archimed] coffee This special line defines the functional group of the plant(s) defined afterward. Here we have two plants that both are from the same group: coffee. This group name is used by ARCHIMED to link each plant to the group models (see the documentation about the models).\nThen comes the information to place the plants in the scene:\n#sceneId objectId FilePath x y z scale inclinationAzimut inclinationAngle rotation 1 1 opf/P6_Ru_ii_L2P02.opf 0 0 0 0 0 0 0 1 2 opf/P6_Ru_ii_L2P02.opf 1 1 0 0 0 0 0 The first line is a comment here. The second and third lines describe a new plant in the scene. Each line specifies ten values:\n the scene id: this value is mandatory, but not used by ARCHIMED (used by AMAPStudio);\n the object id (speaks for itself);\n the path to the 3D object file (.opf or .gwa);\n the coordinates of the object in the scene (x, y and z);\n the scaling factor of the object (not used, neither in ARCHIMED nor AMAPStudio);\n the inclination angle of the object in the azimuth;\n the inclination angle of the object in the zenith;\n and the object rotation around its main vertical axis;  The parameters that are not used in ARCHIMED are still mandatory in the .ops file so the scene can be opened and used in AMAPStudio before and after a simulation.\n  Several functional groups It is possible to add plants from different functional groups in the scene by chaining their functional group name and their positions such as:\n#[Archimed] coffee #sceneId objectId FilePath x y z scale inclinationAzimut inclinationAngle rotation 1 1 opf/coffee.opf 0 0 0 0 0 0 0 1 2 opf/coffee.opf 1 1 0 0 0 0 0 #[Archimed] elaeis #sceneId objectId FilePath x y z scale inclinationAzimut inclinationAngle rotation 1 3 opf/elaeis.opf 0.5 0.5 0 0 0 0 0 1 4 opf/elaeis.opf 1.5 1.5 0 0 0 0 0 You can find the example .ops file here:\n  Attachments   several_groups.ops  (0 ko)     Further details One last row can be added to the .ops file for scene chaining in AMAPStudio. This line is optional and is not used by ARCHIMED anyway:\n#motherId sceneId date -1 1 1 The first value gives the id of the parent scene, -1 for the first scene (no parent), the second value gives the id of the scene, and the last value gives the date of the scene.\nFor more details, the AMAPStudio definition of the .ops file is available here.\n  "
},
{
	"uri": "/3-inputs/4-scene/2-opf/",
	"title": "Plant file",
	"tags": [],
	"description": "",
	"content": "  .opf The .opf file extension stands for Open Plant Format. It allows to store the topology, the geometry and any other attribute of a plant. The format is heavily inspired by the MTG format (Multi-scale Tree Graph) for the topology representation.\nThe file is encoded in the XML format, so many editors can render its structure. The .opf file describes vertices, faces, normals, texture coordinates, materials (colors), attributes and transformation matrices for the geometry.\nA very simple example of a virtual plant with two metamers (two internodes bearing one leaf each) is available here:\n  Attachments   simple_OPF.opf  (9 ko)    The file renders as follows:\n A simple 3D plant by rvezy on Sketchfab  You don‚Äôt need to understand the details about the structure of the .opf files if you‚Äôre not a developer. A standard use-case for users is to build plants using specialized software such as XPlo, VPalm or PRINCIPES. If you‚Äôre a standard user, please go to the next page (especially if it‚Äôs your first time reading).\n If you are more curious (or don‚Äôt like people telling you what to do), or need to develop around .opf files, more details are presented below.\nStructure The .opf file is a simple XML file under the hood. It is designed with several parts (i.e. XML nodes): - meshBDD\n- materialBDD\n- shapeBDD\n- attributeBDD\n- topology\nHere is our example .opf minus the details inside each nodes (stripped information is denoted by [...]):\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;opf version=\u0026quot;2.0\u0026quot; editable=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;meshBDD\u0026gt; [...] \u0026lt;/meshBDD\u0026gt; \u0026lt;materialBDD\u0026gt; [...] \u0026lt;/materialBDD\u0026gt; \u0026lt;shapeBDD\u0026gt; [...] \u0026lt;/shapeBDD\u0026gt; \u0026lt;attributeBDD\u0026gt; [...] \u0026lt;/attributeBDD\u0026gt; \u0026lt;topology class=\u0026quot;Scene\u0026quot; scale=\u0026quot;0\u0026quot; id=\u0026quot;3\u0026quot;\u0026gt; [...] \u0026lt;/topology\u0026gt; \u0026lt;/opf\u0026gt; The details about each node is given below.\nmeshBDD  A plant is a collection of similar components repeated many times (e.g. thousands of leaves). The most efficient way to store a plant into a file is to use reference meshes that describe the average geometry of a given component (e.g. a leaf or an internode), and then to transform this reference mesh to match precisely the geometry of each component. This method reduce the amount of data written in the .opf file because the geometry of each component is only stored in a 4*3 transformation matrix instead of a data heavy mesh. This matrix is then used to transform the reference mesh to match the geometry of a given component.\nHence, the meshBDD node from the .opf file lists all the reference meshes used to build the plant geometry. Here is the structure of the meshBDD from our example. Each reference mesh is represented by a mesh node with a given id, here we have three meshes with id 1, 2 and 0 respectively:\n[...] \u0026lt;meshBDD\u0026gt; \u0026lt;mesh name=\u0026quot;\u0026quot; shape=\u0026quot;\u0026quot; Id=\u0026quot;1\u0026quot; enableScale=\u0026quot;true\u0026quot; \u0026gt; [...] \u0026lt;/mesh\u0026gt; \u0026lt;mesh name=\u0026quot;\u0026quot; shape=\u0026quot;\u0026quot; Id=\u0026quot;2\u0026quot; enableScale=\u0026quot;false\u0026quot; \u0026gt; [...] \u0026lt;/mesh\u0026gt; \u0026lt;mesh name=\u0026quot;\u0026quot; shape=\u0026quot;\u0026quot; Id=\u0026quot;0\u0026quot; enableScale=\u0026quot;false\u0026quot; \u0026gt; [...] \u0026lt;/mesh\u0026gt; \u0026lt;/meshBDD\u0026gt; [...] Our example could be built using 2 meshes only: a reference leaf and a reference internode. It was built using Xplo, and the software decided to use two different reference meshes and materials for the internode for some reason instead of adapting the transformation matrix.\n Each mesh node lists itself five information:\n- the points coordinates as a vector of the form x1 y1 z1 x2 y2 z2 ...;\n- the normal coordinates as a vector of the same form and order than the points;\n- the texture coordinates (textureCoords) as a vector of the form u1 v1 u2 v2 ...;\n- and the faces, listing face nodes, each containing a vector of 3 integers referring to the points index used to build a face Point index are written as i1 i2 i3. The prefered way for a face is to be a triangle (i.e. reference 3 points).\nHere are more details about the first mesh:\n \u0026lt;mesh name=\u0026quot;\u0026quot; shape=\u0026quot;\u0026quot; Id=\u0026quot;1\u0026quot; enableScale=\u0026quot;true\u0026quot; \u0026gt; \u0026lt;points\u0026gt; 0.10162586 -0.0012269035 -0.0 0.3519142 0.22452335 0.03067259 [...] \u0026lt;/points\u0026gt; \u0026lt;normals\u0026gt; -0.17780079 -0.25352615 0.9508477 -0.17780079 -0.25352615 0.9508477 [...] \u0026lt;/normals\u0026gt; \u0026lt;textureCoords\u0026gt; 0.49726775 -0.38636366 0.010928948 0.003787874 0.0 0.46590912 [...] \u0026lt;/textureCoords\u0026gt; \u0026lt;faces\u0026gt; \u0026lt;face Id=\u0026quot;0\u0026quot;\u0026gt; 0 2 4 \u0026lt;/face\u0026gt; \u0026lt;face Id=\u0026quot;1\u0026quot;\u0026gt; 0 4 3 \u0026lt;/face\u0026gt; \u0026lt;face Id=\u0026quot;2\u0026quot;\u0026gt; 4 8 6 \u0026lt;/face\u0026gt; [...] \u0026lt;/faces\u0026gt; \u0026lt;/mesh\u0026gt;  materialBDD The materialBDD is used to declare the material properties for visualization purposes. This node is not used by ARCHIMED, but is still mandatory to follow the .opf standard. It is used when rendering the .opf in e.g. XPlo.\nThe materialBDD is rather short. It lists material nodes that declare the optical properties of each reference node: the emission, ambient, diffuse, specular and shininess.\nThe materialBDD of our example is as follows:\n[...] \u0026lt;materialBDD\u0026gt; \u0026lt;material Id=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;emission\u0026gt;0.0 0.0 0.0 0.0 \u0026lt;/emission\u0026gt; \u0026lt;ambient\u0026gt;1.0 0.0 0.0 1.0 \u0026lt;/ambient\u0026gt; \u0026lt;diffuse\u0026gt;1.0 0.0 0.0 1.0 \u0026lt;/diffuse\u0026gt; \u0026lt;specular\u0026gt;1.0 0.0 0.0 1.0 \u0026lt;/specular\u0026gt; \u0026lt;shininess\u0026gt;10.0 \u0026lt;/shininess\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material Id=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;emission\u0026gt;0.0 0.0 0.0 0.0 \u0026lt;/emission\u0026gt; \u0026lt;ambient\u0026gt;1.0 0.8901961 0.0 1.0 \u0026lt;/ambient\u0026gt; \u0026lt;diffuse\u0026gt;1.0 0.8901961 0.0 1.0 \u0026lt;/diffuse\u0026gt; \u0026lt;specular\u0026gt;1.0 0.8901961 0.0 1.0 \u0026lt;/specular\u0026gt; \u0026lt;shininess\u0026gt;10.0 \u0026lt;/shininess\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/materialBDD\u0026gt; [...] Note that each material has an Id. This id can be different to the one provided in the meshBDD (see next paragraph). It is used to link the material to the mesh from the meshBDD by its Id.\nEach material property (e.g. emission) stores a vector of 4 values for the red, green, blue, and alpha value ([0-1]).\n shapeBDD  The shapeBDD is used to build a shape. A shape is an object that stores a mesh and a material. In other words, it is used to link each mesh to its material properties. Using shape is very powerful because it allows to recycle information whenever possible. For example different component types can have a different reference mesh, but share the same material properties. In this case, no need to create two identical material properties, we can just reference the same material instead when building the shape.\nHere is the shapeBDD of our example:\n[...] \u0026lt;shapeBDD\u0026gt; \u0026lt;shape Id=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;name\u0026gt; Mesh1\u0026lt;/name\u0026gt; \u0026lt;meshIndex\u0026gt;1\u0026lt;/meshIndex\u0026gt; \u0026lt;materialIndex\u0026gt;1\u0026lt;/materialIndex\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;shape Id=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;name\u0026gt; Mesh2\u0026lt;/name\u0026gt; \u0026lt;meshIndex\u0026gt;2\u0026lt;/meshIndex\u0026gt; \u0026lt;materialIndex\u0026gt;0\u0026lt;/materialIndex\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;shape Id=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;name\u0026gt; Mesh0\u0026lt;/name\u0026gt; \u0026lt;meshIndex\u0026gt;0\u0026lt;/meshIndex\u0026gt; \u0026lt;materialIndex\u0026gt;0\u0026lt;/materialIndex\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/shapeBDD\u0026gt; [...] It lists 3 different shapes, with each a different reference mesh and material.\n attributeBDD  Any kind of additional attributes (read ‚Äúdata‚Äù) can be attached to a topology node (i.e. decomp, follow and branch, see next paragraph). The attributeBDD is used to define the attribute name and class, i.e. data type, integer, float, string, or AMAPStudio custom keyword (e.g. Centimetre).\nHere is the attributeBDD from our example:\n[...] \u0026lt;attributeBDD\u0026gt; \u0026lt;attribute name=\u0026quot;XX\u0026quot; class=\u0026quot;Double\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;YY\u0026quot; class=\u0026quot;Double\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;ZZ\u0026quot; class=\u0026quot;Double\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;FileName\u0026quot; class=\u0026quot;String\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;Length\u0026quot; class=\u0026quot;Centimetre\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;Width\u0026quot; class=\u0026quot;Centimetre\u0026quot;/\u0026gt; \u0026lt;attribute name=\u0026quot;XEuler\u0026quot; class=\u0026quot;Double\u0026quot;/\u0026gt; \u0026lt;/attributeBDD\u0026gt; [...] It declares seven optional attributes that can be optionally attached to a topology node. These attributes are generally computed by a software and attached to the .opf. For example ARCHIMED uses attributes to attach simulation outputs to .opfs from the scene, e.g. the intercepted PAR of each component. These attributes are handy for visualization purposes.\nNote that attributes are not updated automatically when other data is modified. For example the example attributeBDD provides a ‚ÄúLength‚Äù attribute, which is used to get rapidly the length of the component. But if a user modified the actual lenght of a component of the .opf by modifying its transformation matrix, the ‚ÄúLength‚Äù attribute will not be updated to the new length. It is then important to keep in mind that attributes are optional data attached to a node, but not necessarily up to date.\n  topology The topology node is used to describe the relational connection between the different components of a plant, i.e. the organization of the plant. The components used are a natural decomposition of the plant, i.e. an internode or a leaf that are used to decompose the plant in metamers, and not an artificial decomposition such as a set of 10 cm long sections of axes.\nThe leafy axis resulting from a succession of phytomers (or metamers) arising from apical bud growth and development. Drawing D. Barth√©l√©my, CIRAD. Source\n The description follows the rules of the widely used Multi-scale Tree Graph (MTG). Please read the article from Godin and Caraglio (1998) for a nice introduction to the concept.\nBut the topology node from the .opf enhance this concept by adding further attributes to each component, allowing a close coupling between the plant topology and geometry.\n From Godin et al.¬†(1999) Topology deals with the physical connections between plant components, while geometry includes the shape, size, orientation and spatial location of the components.\n For example, each component to be rendered in 3D has a shapeIndex that points to the reference shape used to build the geometry of the component, and a geometry node that stores the transformation matrix applied to the reference mesh to compute the geometry of the component.\nThe topology is built by a succession of components, and the link between them is described using three main keywords:\n- follow, for a succession of growth units created by apical meristems;\n- branch for a ramification;\n- decomp, for a decomposition, e.g a reiteration;\nHere is the topology from our example file, without the details:\n[...] \u0026lt;topology class=\u0026quot;Scene\u0026quot; scale=\u0026quot;0\u0026quot; id=\u0026quot;3\u0026quot;\u0026gt; # -\u0026gt; instantiate the topology with a scene (scale 0) \u0026lt;decomp class=\u0026quot;Individual\u0026quot; scale=\u0026quot;1\u0026quot; id=\u0026quot;2\u0026quot;\u0026gt; # -\u0026gt; instantiate an individual plant (scale 1) [...] \u0026lt;decomp class=\u0026quot;Axis\u0026quot; scale=\u0026quot;2\u0026quot; id=\u0026quot;4\u0026quot;\u0026gt; # -\u0026gt; instantiate the base axis of the plant [...] \u0026lt;decomp class=\u0026quot;Internode\u0026quot; scale=\u0026quot;6\u0026quot; id=\u0026quot;5\u0026quot;\u0026gt; # -\u0026gt; Start building the plant: first internode [...] \u0026lt;branch class=\u0026quot;Leaf\u0026quot; scale=\u0026quot;2\u0026quot; id=\u0026quot;6\u0026quot;\u0026gt; # -\u0026gt; The 1st internode bears a leaf, branched to it [...] \u0026lt;/branch\u0026gt; \u0026lt;/decomp\u0026gt; \u0026lt;follow class=\u0026quot;Internode\u0026quot; scale=\u0026quot;6\u0026quot; id=\u0026quot;10\u0026quot;\u0026gt; # -\u0026gt; The 2d internode follows the 1st internode [...] \u0026lt;branch class=\u0026quot;Leaf\u0026quot; scale=\u0026quot;2\u0026quot; id=\u0026quot;11\u0026quot;\u0026gt; # -\u0026gt; The 2d leaf is branched into the 2d internode [...] \u0026lt;/branch\u0026gt; \u0026lt;/follow\u0026gt; \u0026lt;/decomp\u0026gt; \u0026lt;/decomp\u0026gt; \u0026lt;/topology\u0026gt; [...] We can build the topology of our plant only by using the three keywords provided by the MTG method. This method is very powerful and is sufficient to build any topology configuration, from very simple plants until the most complex ones.\nWe see that each component is delimited by how it is connected to the previous one, and each one has also a class, a scale and an id. The scale is not very important for our purposes, but other two are:\n The class is used to declare a component type. This type can be anything, e.g. a leaf or an internode, but also a young_leaf and an old_leaf. The class is especially important in ARCHIMED (compared to AMAPStudio) because it is then used to associate particular models and parameter values to each component type. We will see that later in the documentation about the models.\n The id is used as a unique identifier for the components. It helps us find e.g. a particular leaf in the whole plant.\n   geometry As said previously, the geometry of the plant is the shape, size, orientation and spatial location of the components. It is defined by linking several information together: the reference shape declared earlier (see shapeBDD paragraph), and a transformation matrix given as an attribute to each component from the topology.\nThe transformation matrix is declared in a geometry node. This node also declares the shapeIndex to point to the reference shape to use, and two nodes called dUp and dDwn used for mesh tapering (e.g.¬†make a cone from a cylinder). The geometry of the first leaf from our example .opf file is as follows:\n[...] \u0026lt;branch class=\u0026quot;Leaf\u0026quot; scale=\u0026quot;2\u0026quot; id=\u0026quot;6\u0026quot;\u0026gt; # -\u0026gt; declare a component (type: Leaf), branched to the previous component \u0026lt;Length\u0026gt;10.0\u0026lt;/Length\u0026gt; # -\u0026gt; Add optional attribute Length \u0026lt;Width\u0026gt;6.0\u0026lt;/Width\u0026gt; # -\u0026gt; Add optional attribute Width \u0026lt;geometry class=\u0026quot;Mesh\u0026quot;\u0026gt; # -\u0026gt; Add a geometry node \u0026lt;shapeIndex\u0026gt;1\u0026lt;/shapeIndex\u0026gt; # -\u0026gt; The shape 1 will be used as reference \u0026lt;mat\u0026gt; # -\u0026gt; The shape 1 will be transformed using this matrix 8.6602545 0.0 -0.5 -1.7484555E-7 0.0 1.0 0.0 0.0 5.0 0.0 0.86602545 4.0 \u0026lt;/mat\u0026gt; \u0026lt;dUp\u0026gt;6.0\u0026lt;/dUp\u0026gt; # -\u0026gt; Add tapering to the upper part of the shape \u0026lt;dDwn\u0026gt;6.0\u0026lt;/dDwn\u0026gt; # -\u0026gt; Add tapering to the lower part of the shape \u0026lt;/geometry\u0026gt; \u0026lt;/branch\u0026gt; [...] The transformation matrix is an homogeneous matrix reduced to a 4*3 matrix because the 4th row of the matrix is always the same: [0 0 0 1]. Please read this wonderful resource for a nice introduction to homogeneous coordinates, translation, scaling and rotation. This method allows to reduce the data needed to describe the geometry in the .opf for fast IO and low disk space usage. The geometry is not mandatory for all components. Some components are simply not rendered, such as the Scene for example. In this case a geometry can be optionally declared, but no shapeIndex is given.\n  Further ressources See this online course on the greenlab website and the AMAPStudio documentation for more information.\n   "
},
{
	"uri": "/3-inputs/4-scene/3-gwa/",
	"title": "Geometry file",
	"tags": [],
	"description": "",
	"content": "  .gwa The .gwa files are used to represent any geometrical object. It is based on the same format than the .opf (and is an XML too), but without the topology.\nA simple example of a virtual table is available here:\n  Attachments   table.gwa  (12 ko)    And here is a 3d render of this file:\n A simple table by rvezy on Sketchfab  If you open the file, you‚Äôll see several sextions. First, there is the header:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;gwa version=\u0026quot;1.0\u0026quot;\u0026gt; The first line defines the xml format, and the second one defines the gwa format.\nThen comes the attributes:\n\u0026lt;attributes\u0026gt; \u0026lt;attribute name=\u0026quot;Color\u0026quot; class=\u0026quot;Color\u0026quot;/\u0026gt; \u0026lt;/attributes\u0026gt; It is the same as for the attributeBDD from the opf format (go there for more details).\nThen the meshes are defined one after another with their respective data: points, normals, face:\n\u0026lt;mesh id=\u0026quot;2\u0026quot; label=\u0026quot;Cylinder\u0026quot;\u0026gt; \u0026lt;points\u0026gt; -245.0 -500.0 0.0 -245.0 -500.0 60.0 -245.0 -500.0 120.0 -245.0 -500.0 180.0 -245.0 -500.0 240.0 -245.0 -500.0 300.0 -250.0 -495.0 0.0 -250.0 -495.0 60.0 -250.0 -495.0 120.0 -250.0 -495.0 180.0 -250.0 -495.0 240.0 -250.0 -495.0 300.0 -255.0 -500.0 0.0 -255.0 -500.0 60.0 -255.0 -500.0 120.0 -255.0 -500.0 180.0 -255.0 -500.0 240.0 -255.0 -500.0 300.0 -250.0 -505.0 0.0 -250.0 -505.0 60.0 -250.0 -505.0 120.0 -250.0 -505.0 180.0 -250.0 -505.0 240.0 -250.0 -505.0 300.0 \u0026lt;/points\u0026gt; \u0026lt;normals\u0026gt; -1.0 -2.683151E-7 0.0 -1.0 0.0 0.0 -1.0 0.0 0.0 -1.0 0.0 0.0 -1.0 0.0 0.0 -1.0 2.683151E-7 0.0 2.7502296E-7 -1.0 0.0 -2.3477572E-8 -1.0 0.0 -2.3477572E-8 -1.0 0.0 -2.3477572E-8 -1.0 0.0 -2.3477572E-8 -1.0 0.0 -2.683151E-7 -1.0 0.0 1.0 2.7502296E-7 0.0 1.0 -2.3477572E-8 0.0 1.0 -2.3477572E-8 0.0 1.0 -2.3477572E-8 0.0 1.0 -2.3477572E-8 0.0 1.0 -2.683151E-7 0.0 -2.7502296E-7 1.0 0.0 2.3477572E-8 1.0 0.0 2.3477572E-8 1.0 0.0 2.3477572E-8 1.0 0.0 2.3477572E-8 1.0 0.0 2.683151E-7 1.0 0.0 \u0026lt;/normals\u0026gt; \u0026lt;faces\u0026gt; \u0026lt;face Id=\u0026quot;0\u0026quot;\u0026gt; 0 6 7 \u0026lt;/face\u0026gt; \u0026lt;face Id=\u0026quot;1\u0026quot;\u0026gt; 7 1 0 \u0026lt;/face\u0026gt; [...] \u0026lt;/faces\u0026gt; \u0026lt;Color\u0026gt;Color 0 0 255\u0026lt;/Color\u0026gt; \u0026lt;/mesh\u0026gt; where [...] denotes data that is not displayed here for clarity.\nThe format of the meshes follows the one from the meshBDD in the opf format, see this documentation for more details.\nMore information about the .gwa files are available from the AMAPStudio documentation).\n "
},
{
	"uri": "/3-inputs/5-models/",
	"title": "Models",
	"tags": [],
	"description": "",
	"content": "  Biophysical models ARCHIMED provides many biophysical models to compute the light interception, the energy balance and the photosynthesis of objects in the scene. This chapter describes how the models are configured.\n "
},
{
	"uri": "/3-inputs/5-models/1-models/",
	"title": "Simple model file",
	"tags": [],
	"description": "",
	"content": "  In ARCIHMED, an object is defined by:\n- its geometry, read from an .opf or a .gwa file;\n- (optionally) its topology, only read from an .opf file;\n- its functional group, read from an .ops file.\nThe geometry (and topology) of an object is built using components (see the opf documentation). For example a simple coffee tree can be built using two components: leaves and internodes. Each component can have its own models and parameters. For example we know that internodes won‚Äôt make any photosynthesis, so they don‚Äôt have any photosynthesis model.\nYou can download the example file to follow along here:\n  Attachments   plant_coffee_simple.yml  (2 ko)    Description Functional group The model files are in the YAML format, so they always start with a --- line. Then comes the Group parameter that defines the name of the functional group of the given model file:\n--- Group: coffee A functional group can be anything: e.g. a plant species, a family, a variety or even a progeny. The point being that each plant in a scene belongs to a functional group, and that all plants from a given functional group share the same component types and the same model properties defined in the model file of its functional group.\n Component type The Type parameter defines the component types used to build the object (e.g.¬†leaves and branches components are used to build a plant). The names of the components listed here should match the same names given in the topology node of the .opf file (see the documentation about the opf files). In the example given earlier in the organization chapter, the .opf file for a coffee tree gives two different components: Leaf and Metamer (read internode here). A model file adapted for this .opf will list those components as follows:\n--- Group: coffee Type: Metamer: [...] Leaf: [...] With the [...] further information not given here for clarity but that will be detailed hereafter.\nThe name of the Type should match exactly the names given in the topology node of the .opf file. Read the documentation about the opf files if in doubt.\n  Processes For each component type, we can simulate at the moment three different processes:\n- the light interception: Interception;\n- the photosynthesis: Photosynthesis;\n- and the stomatal conductance: StomatalConductance.\nIf a process has to be simulated for a given component, it should be listed under the component name such as:\n--- Group: coffee Type: Metamer: Interception: [...] Leaf: Interception: [...] Photosynthesis: [...] StomatalConductance: [...] The name of the process should match exactly: Interception, Photosynthesis and StomatalConductance\n In this example, only the light interception will be simulated for the Metamer type, and the light interception, photosynthesis and stomatal conductance will be simulated for the Leaf type.\n Models The processes are simulated by dedicated models. There can be one or more models available to simulate a process, with a set of parameters for each.\nHere is a simple example of a model used to simulate the interception process for the Metamer:\n--- Group: coffee Type: Metamer: Interception: model: Translucent transparency: 0 optical_properties: PAR: 0.15 NIR: 0.9 [...] Here the light interception process is simulated using the Translucent model. This model has two main parameters:\n- the transparency, which is set to 0 (the Metamer is not transparent at all);\n- the optical_properties of the Metamer, defined for the PAR (0.15) and for the NIR (0.9).\nThe Leaf component simulates the light interception too, but also add the photosynthesis and stomatal conductance. Here is an example parametrization for the models used:\nGroup: coffee # -\u0026gt; functional group Type: # -\u0026gt; component types Metamer: # -\u0026gt; Metamer component (name must match OPF values) [...] # -\u0026gt; further information not displayed here for clarity Leaf: # -\u0026gt; Leaf component (name must match OPF values) Interception: # -\u0026gt; Light interception process model: Translucent # -\u0026gt; Name of the model used transparency: 0 # -\u0026gt; Parameter name and value optical_properties: # -\u0026gt; Parameter with several values PAR: 0.15 # -\u0026gt; First value for the optical_properties parameter (PAR) NIR: 0.9 # -\u0026gt; Second value for parameter, here for NIR Photosynthesis: # -\u0026gt; Photosynthesis process model: FarquharEnBalance # -\u0026gt; Name of the model used tempCRef: 25 # -\u0026gt; Parameter name and value [...] StomatalConductance: # -\u0026gt; Stomatal conductance process model: Medlyn # -\u0026gt; Name of the model used g0: -0.03 # -\u0026gt; Parameter name and value g1: 12 # -\u0026gt; Parameter name and value So here we have a coffee as a functional group, and two component types called Metamer and Leaf, for which the Interception process will be simulated using the Translucent model that has 3 parameters - the transparency, the scattering factor for the PAR, and for the NIR - all parameterized with some values. The Leaf component type also simulates the Photosynthesis and the StomatalConductance processes, with a given model (FarquharEnBalance and Medlyn resp.) and their respective parameters.\nA list of all models available for each process is available in the next page.\n Several models can be parameterized at the same time for each process using several model instances, in which case the input format is modified to:\n[...] StomatalConductance: # -\u0026gt; Process use: Medlyn_generic # -\u0026gt; Name of the model instance to use Medlyn_generic: # -\u0026gt; Name of a model instance (free name) model: Medlyn # -\u0026gt; Name of the model used in the Medlyn_generic instance g0: -0.03 # -\u0026gt; Parameter names and values g1: 12 Medlyn_caturra: # -\u0026gt; Name of a 2nd model instance (free name) model: Medlyn # -\u0026gt; Name of the model used in this instance g0: -0.03 g1: 12.5 Yin-Struik_caturra: # -\u0026gt; Name of a 3rd model instance (free name) model: Yin-Struik # -\u0026gt; Name of the model used in the instance g0: 0.02089956 a1: 0.9 b1: 0.15 [...] Here for the conductance process, we have three model instances: Medlyn_generic, Medlyn_caturra and Yin-Struik_caturra. The first two model instances use the same model (i.e. Medlyn), but have a different name (Medlyn_generic and Medlyn_caturra) and different parameter values. The last one is an instance of the Yin-Struik model called Yin-Struik_caturra. This method allows to parameterize several models or the same model with different values on the same file, and to chose only one to use. This is especially useful when dealing with different possible parameterization in the same file, or to be able to easily share a file with different possible parametrizations.\n  "
},
{
	"uri": "/3-inputs/5-models/2-models_list/",
	"title": "List of the models",
	"tags": [],
	"description": "",
	"content": "  Here is a list of all models available for each process.\nInterception There are two three different models available in ARCHIMED to compute their light interception and scattering: Translucent, ignore and VirtualSensor.\nTranslucent This model has two set of parameters :\n transparency: between 0 and 1. 0 is not transparent (opaque), and 1 fully transparent. If e.g.¬†0.3, 30% of the incoming light is intercepted by the component (interception = radiation * (1-transparency)), and 30% is directly transmitted (not being part of the interception). Not to be confused with the scattering of the light that is computed using the intercepted light (transmitted + scattered light),\n optical_properties. Used to parametrize the scattering factors for each waveband to compute how much light is absorbed, reflected and transmitted by the component (i.e. a range of wavelength).\n  Decomposition of light paths after a hit.\n Usually the radiation remaining for each is computed using coefficients, such as the sum of all coefficients is equal to 1:\n\\(\\alpha + \\rho + \\tau = 1\\)\nwith \\(\\alpha\\) the coefficient of absorptance, \\(\\rho\\) the reflectance and \\(\\tau\\) the transmittance.\nThen, the absorbed (\\(R_a\\)), reflected (\\(R_r\\)) and transmitted (\\(R_t\\)) light are computed as:\n\\(R_a = \\alpha \\cdot R_i\\)\n\\(R_r = \\rho \\cdot R_i\\)\n\\(R_t = \\tau \\cdot R_i\\)\nBut in ARCHIMED we consider the reflectance coefficient equal to the transmittance coefficient (\\(\\rho = \\tau\\)), so we use only one value to parameterize the model: the scattering factor (\\(\\sigma\\)). It is the sum of \\(\\rho\\) and \\(\\tau\\), such as \\(\\sigma = \\rho + \\tau\\). Then we can compute \\(R_a\\), \\(R_r\\) and \\(R_t\\) as:\n\\(R_a = R_i \\cdot (1 - \\rho + \\tau)\\)\n\\(R_r = R_i \\cdot \\frac{(1-\\sigma)}{2}\\)\n\\(R_t = R_i \\cdot \\frac{(1-\\sigma)}{2}\\)\nIn ARCHIMED, the components are considered lambertian surfaces, i.e.¬†they scatter the light uniformly in all directions.\n The scattering factors are given for each waveband to be simulated by the model. This is typically for the photosynthetically active radiation (PAR, typically 400 to 700 nm) and the near-infrared (NIR, typically 780 nm to 2500 nm) but the user can also define custom wavebands.\nHere is an example parameterization using this model:\nInterception: use: Translucent_1 Translucent_1: model: Translucent transparency: 0 optical_properties: PAR: 0.15 NIR: 0.9  ignore This model totally ignore the object, so it is not used during the computation of light interception, as if it never existed. No parameter.\nHere is an example parameterization using this model:\nInterception: model: ignore  VirtualSensor This model is used for special components called virtual sensors. They are used to know the incoming radiation for a given point in space. See this chapter for more details. No parameters.\nHere is an example parameterization using this model:\nInterception: model: VirtualSensor  Example parameterization Here is an example parameterization of a component with all three models, and using the first one:\nGroup: test Type: example_component: Interception: use: Translucent_model Translucent_model: model: Translucent transparency: 0 optical_properties: PAR: 0.15 NIR: 0.9 ignore_model: model: ignore sensor: model: VirtualSensor The name of a parameterization group is free. For example we can replace Translucent_model by anything, such as foo.\n Interception: use: foo foo: model: Translucent transparency: 0 optical_properties: PAR: 0.15 NIR: 0.9   Photosynthesis There are two models to compute the photosynthesis in ARCHIMED: FarquharEnBalance and NRH. Here is an example parameterization using those models:\nPhotosynthesis: use: Farquharcoffee_1 Farquharcoffee_1: model: FarquharEnBalance tempCRef: 25 jMaxRef: 250 vcMaxRef: 200 rdRef: 0.6 theta: 0.853 LWratio: 1.5 nFaceStomata: 1 leafEmissivity : 0.98 delta_T_init: -2 epsilon: 0.1 iter_T_max: 10 iter_A_max: 50 NRH_coffee: model: NRH theta: 0.6711 pmax: 32.91 alpha: 0.06906 rd: 1.612 FarquharEnBalance This model is the most complete. It couples the photosynthesis model of Farquhar, von Caemmerer, and Berry (1980), a model for stomatal conductance (see next paragraph), and a detailed energy balance model to iteratively solve the stomatal conductance and the leaf temperature.\nThis model has 12 parameters:\n tempCRef (¬∞C): reference temperature of measurements\n jMaxRef (\\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): value of maximum rate of electron transport (Jmax) at the reference temperature\n vcMaxRef (\\(\\mu mol_{electron} \\cdot m^{-2} \\cdot s^{-1}\\)): Maximum carboxylation rate at the reference temperature\n rdRef (\\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): mitochondrial respiration in the light at reference temperature (other than that associated with the PCO cycle).\n theta: the curvature of the light-response curve of electron transport.\n LWratio: average lenght / width ratio for the component. Used to compute the boundary layer conductance.\n nFaceStomata: number of faces of the component with stomata (1: hypostomatal, 2: amphistomatal leaf).\n leafEmissivity (0-1): Ratio between the leaf radiant emittance (also called radiant exitance) compared to the one of a black body.\n delta_T_init (¬∞C): initialization of the leaf temperature in relation to Tair (Tleaf = Tair - delta_T_init). This initialization is done every time the function is called (at every iteration of the assimilation conmputation), then the leaf temperature is computed by iteration, and its last value is used on the computation of the assimilation, but is reset to delta_T_init before re-doing the calculation of Tleaf. This is done to avoid heavy divergence of both optimization algorithms.\n epsilon (¬∞C): criteria for convergence of the leaf temperature computation (difference between previous Tleaf and current Tleaf)\n iter_T_max (-): maximum number of iterations allowed for leaf temperature computation\n iter_A_max (-): maximum number of iterations allowed for assimilation and conductance computation\n   NRH The NRH (Non-Rectangular Hyperbola) model is used to compute the photosynthesis much more simply (but less reliably). It has four parameters:\n pmax (\\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): maximum (i.e light-saturated) net photosynthetic rate\n theta (-): convexity of the PLR (photosynthetic Light Response) curve\n alpha (\\(\\mu mol_{CO_2} \\cdot \\mu mol_{photon}^{-1}\\)): quantum yield of assimilation (initial slope of the PLR)\n rd (\\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): dark respiration rate.\n    Stomatal Conductance The stomatal conductance is crucial to estimate the water and carbon fluxes from the leaves to the environment. There are two models of stomatal conductance yet: Medlyn and 'Yin-Struik'. Here is an example parameterization of the models:\nStomatalConductance: use: Medlyn_generic Medlyn_generic: model: Medlyn g0: -0.03 g1: 12 Medlyn_caturra: model: Medlyn g0: -0.03 g1: 12.5 \u0026#39;Yin-Struik_caturra\u0026#39;: model: \u0026#39;Yin-Struik\u0026#39; g0: 0.02089956 a1: 0.9 b1: 0.15 Please note the ‚Äú‚Äô‚Äù around the name of the Yin-Struik model. It is used to escape the ‚Äú-‚Äù character inside the name, and is mandatory.\n Medlyn The model of Medlyn et al. (2011) computes the leaf stomatal conductance using the vapor pressure deficit (VPD) such as:\n\\(G_s=G_0+\\left(1+\\frac{G_1}{\\sqrt{VPD}}\\right)\\cdot\\frac{A}{C_a-\\Gamma}\\)\nwhere \\(G_s\\) is the stomatal conductance in \\(mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\), VPD is the vapor pressure deficit in kPa, A is the net assimilation rate in \\(\\mu mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\), \\(C_a\\) the atmospheric \\(CO_2\\) concentration in ppm, and \\(\\Gamma\\) the \\(CO_2\\) compensation point of assimilation in the presence of dark respiration (so in the absence of day respiration (Rd)). The model has two parameters:\n g0 (\\(mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): residual conductance\n g1 (-): slope of the conductance\n   ‚ÄòYin-Struik‚Äô The model from Yin and Struik (2017) (equ. 11) also relates the stomatal conductance to the VPD using the following equation:\n\\(G_s=G_0+\\frac{A+R_d}{C_s-C_s^\\ast}f\\left(VPD\\right)\\)\nwith \\(C_s\\) the \\(CO_2\\) concentration at the leaf surface, and \\(C^{\\star}_s\\) is the equivalent of \\(\\Gamma\\) based on \\(C_s\\) (see full article, eq. 11).\nIn ARCHIMED, \\(C^{\\star}_s\\) is given by \\(\\Gamma^\\star_{ref}\\) corrected by the temperature, and \\(C_i\\) is used instead of \\(C_s\\).\nThe \\(f\\left(VPD\\right)\\) function is computed as:\n\\(f_{VPD}=\\frac{1}{\\frac{1}{\\max\\left(a_1-b_1\\cdot VPD,\\ 0.01\\right)-1}}\\)\nThe model has three parameters:\n g0 (\\(mol_{CO_2} \\cdot m^{-2} \\cdot s^{-1}\\)): the residual conductance\n a1 (-): Ci:Ca ratio in water vapour-saturated air\n b1 (-): slope of the decrease of this ratio with increasing VPD.\n    References Farquhar, G. D., S. von Caemmerer, and J. A. Berry. 1980. ‚ÄúA Biochemical Model of Photosynthetic CO2 Assimilation in Leaves of C3 Species.‚Äù Planta 149 (1): 78‚Äì90.\n Medlyn, Belinda E., Remko A. Duursma, Derek Eamus, David S. Ellsworth, I. Colin Prentice, Craig V. M. Barton, Kristine Y. Crous, Paolo De Angelis, Michael Freeman, and Lisa Wingate. 2011. ‚ÄúReconciling the Optimal and Empirical Approaches to Modelling Stomatal Conductance.‚Äù Global Change Biology 17 (6): 2134‚Äì44. https://doi.org/10.1111/j.1365-2486.2010.02375.x.\n Yin, X., and P. C. Struik. 2017. ‚ÄúCan Increased Leaf Photosynthesis Be Converted into Higher Crop Mass Production? A Simulation Study for Rice Using the Crop Model GECROS.‚Äù J Exp Bot 68 (9): 2345‚Äì60. https://doi.org/10.1093/jxb/erx085.\n   "
},
{
	"uri": "/3-inputs/5-models/3-soil_model/",
	"title": "Soil model",
	"tags": [],
	"description": "",
	"content": "  The soil file is the same as any plant file so far (e.g.¬†group, type, model parameters), but will be populated with new parameters soon. It is identified as a soil file if it uses the Cobblestone component type.\n"
},
{
	"uri": "/3-inputs/5-models/4-virtual_sensors/",
	"title": "Virtual sensor",
	"tags": [],
	"description": "",
	"content": "  More information on how to use virtual sensors soon.\n"
},
{
	"uri": "/3-inputs/6-meteo/",
	"title": "Meteorology",
	"tags": [],
	"description": "",
	"content": "  meteo.csv The meteorology file is used to input variables related to the environment. It is a file prepared in the CSV format where each column is a variable, and each line is a time step. A time step is a given period of time, it can be a period of 1 minute or a period of 100 days (but see the section about that below).\nFile format The file is a CSV file (semicolon separated) enriched by optional parameters as comments in the header (and following the YAML format).\nYou can download an example file here:\n  Attachments   meteo.csv  (0 ko)    The file is structured as follows:\n#\u0026#39; name: Aquiares #\u0026#39; latitude: 15.0 # in degrees #\u0026#39; altitude: 100.0 # in meters #\u0026#39; use : relativeHumidity clearness date;hour_start;hour_end;temperature;relativeHumidity;VPD;clearness;Re_SW_f;wind;atmosphereCO2_ppm 2016/06/12;12:00:00;12:30:00;25;60;150;0.75;500;1;380 2016/06/12;12:30:00;13:00:00;26;62;150;0.75;500;1.5;380 2016/06/12;13:00:00;13:30:00;25.3;58;150;0.75;500;1.5;380 The four lines at the beginning are YAML-formatted metadata used as input parameters for ARCHIMED. They define properties of the site where the data was measured. The first one is the name of the site (completely free), then comes its latitude (degrees) and altitude (meters). The use parameter defines which column is used when several related (i.e.¬†concurrent) variables are defined in the data. In our example the relativeHumidity and the VPD are declared, and the user must choose which one to use.\nThe first line after the commented lines defines the column names. These names are all fixed and should be matched exactly (ARCHIMED is case-sensitive).\nHere is a table summarizing the information about those variables:\n  Variable Unit Description If.missing Example    date Y/m/d Date of the time step NA 17/09/2020  hour_start H:M:S Beginning of the time step NA 12:00:00  hour_end H:M:S End of the time step NA 12:30:00  temperature Celsius Air temperature (above canopy) NA 25  relativeHumidity % Air relative humidity (above canopy) NA 60  VPD hPa Air vapor pressure deficit (above canopy) NA 2  clearness % Sky clearness NA 0.6  Re_SW_f MJ m-2 s-1 Incoming short wave radiation flux NA 500  wind m s-1 wind speed (above canopy) NA 1.5  atmosphereCO2_ppm ppm Air CO2 concentration NA 420     Some thought on time steps duration The duration of a time step is up to the user, and mainly depends on the use-case, the variables requested and the precision needed. Shorter time-steps tends to give best results because they allow to better integrate non-linear processes that are not well integrated otherwise (e.g. a rapid change in the incoming radiation on a leaf can impact greatly its energy balance).\nIn general we recommend time-steps of maximum 30-minutes for simulations with biophysical processes (e.g. photosynthesis, energy balance, transpiration). This is based on the assumption that these variables can be safely considered at steady-state at or below a 30-minute time range.\nIf only the light interception is needed, the time step can be much larger because the model use the true position of the sun every radiation_timestep (parameter from the configuration file), and not every step in the meteorology file.\nFor all other variables, there is a trade-off between the duration of each step and their number to optimize both the predictions and the time of computation. For example if we need to simulate one day at 30-minute time-steps, it will require 48 time-steps in total, bu only 24 with one hour time-steps. The latter simulation will be almost twice as fast as the former, but will probably lead to a greater simulation error compared with measurements.\nThe cache_radiation parameter can alleviate this effect though (parameter from the configuration file). It allows to compute the results of the light interception for each direction relative to the global radiation, and to cache the results for further use in other time-steps. It is generally admitted this parameter should be set to true when the number of time-steps to simulate is greater than the number of directions (due to overheads on computing the cached radiation).\n   "
},
{
	"uri": "/3-inputs/7-power_users/",
	"title": "Power users",
	"tags": [],
	"description": "",
	"content": "  More information soon about YAML anchors, more complex examples, advanced parameters‚Ä¶\nYAML anchors More information about using anchors in YAML files soon.\n Command line args More information about using the command line options from ARCHIMED soon.\n Advanced parameters More information about using the advanced parameters soon.\n "
},
{
	"uri": "/3-inputs/8-voxels/",
	"title": "Working with voxels",
	"tags": [],
	"description": "",
	"content": "  More information soon about using voxel files.\nüì¶ ‚îú‚îÄ‚îÄ üìúconfig_vox.yml # -\u0026gt; Same here, but for a voxel scene ‚îú‚îÄ‚îÄ üìúconst.yml # -\u0026gt; constants used in the model ‚îú‚îÄ‚îÄ üìúmeteo.csv # -\u0026gt; the meteorology file ‚îú‚îÄ‚îÄ üìÇmodel # -\u0026gt; all the models configuration files are listed in this folder ‚îÇ¬†‚îî‚îÄ‚îÄ üìúturbid_medium.yml # An example config for a turbid medium (i.e. voxels) ‚îî‚îÄ‚îÄ üìúsoil.yml # An example soil file "
},
{
	"uri": "/4-outputs/",
	"title": "Outputs",
	"tags": [],
	"description": "",
	"content": "  Chapter 2  Model outputs More information soon.\n "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]